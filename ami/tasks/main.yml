---
- name: searching for CentOS 7 AMI for your region
  ec2_ami_find:
    name: "CentOS Linux 7 x86_64*"
    region: "{{ ec2_region }}"
    owner: 679593333241
    virtualization_type: hvm
    sort: name
    sort_order: descending
    sort_end: 1
  register: amis_found
  
- name: Retrieve default VPC ID
  local_action:
    module: ec2_vpc_net_facts
    region: "{{ ec2_region }}"
    filters:
      cidr_block: "172.31.0.0/16"
  register: default_vpc
  
- name: retrieving default subnet ID
  local_action:
    module: ec2_vpc_subnet_facts
    region: "{{ ec2_region }}"
    filters:
      vpc_id: "{{ default_vpc.vpcs.0.id }}"
  register: subnet_result

- name: creating postgresql security group
  local_action:
    module: ec2_group
    name: dnsg_postgresql
    description: "postgresql ingress and unrestricted egress rules (ansible)"
    vpc_id: "{{ default_vpc.vpcs.0.id }}"
    region: "{{ ec2_region }}"
    rules:
      - proto: tcp
        from_port: 22
        to_port: 22
        cidr_ip: 0.0.0.0/0
      - proto: tcp
        from_port: 5432
        to_port: 5432
        cidr_ip: 172.31.0.0/16
    rules_egress:
      # Allow all outbound
      - proto: all
        cidr_ip: 0.0.0.0/0
  register: sg_postgresql

- name: checking {{ ec2_region }}-postgresql-private-key.pem
  stat: path="./{{ ec2_region }}-postgresql-private-key.pem"
  register: existing_key

- name: generating public key from {{ ec2_region }}-postgresql-private-key.pem
  command: "/usr/bin/ssh-keygen -f {{ ec2_region }}-postgresql-private-key.pem -y"
  register: public_key_from_pem
  when: existing_key.stat.exists == True
      
- name: using existing {{ ec2_region }}-postgresql
  ec2_key:
    region: "{{ ec2_region }}"
    state: present
    name: "{{ ec2_region }}-postgresql"
    key_material: "{{ public_key_from_pem.stdout }}" 
  register: old_keypair
  when: existing_key.stat.exists == True
  
- set_fact: keypair="{{ old_keypair }}"
  when: existing_key.stat.exists == True
  
- name: creating {{ ec2_region}}-postgresql
  ec2_key:
    name: "{{ ec2_region }}-postgresql"
    region: "{{ ec2_region }}"
  register: new_keypair
  when: existing_key.stat.exists == False

- set_fact: keypair="{{ new_keypair }}"
  when: existing_key.stat.exists == False

- name: saving {{ ec2_region }}-postgresql
  copy:
    dest: "./{{ keypair.key.name }}-private-key.pem"
    content: "{{ keypair.key.private_key }}"
    mode: 0400
  when:
    - existing_key.stat.exists == False
    - keypair.changed

- name: launch AMI
  local_action:
    module: ec2
    key_name: "{{ keypair.key.name }}"
    group_id: "{{ sg_postgresql.group_id }}"
    instance_type: t2.micro
    image: "{{ amis_found.results[0].ami_id }}"
    vpc_subnet_id: "{{ subnet_result.subnets.0.id }}"
    region: "{{ ec2_region }}"
    assign_public_ip: yes
    wait: true
    exact_count: 1
    count_tag:
      Name: "{{ tenant }}_postgresql"
      Tenant: "{{ tenant }}"
      Application: postgresql
    instance_tags:
      Name: "{{ tenant }}_postgresql"
      Tenant: "{{ tenant }}"
      Application: postgresql
    ebs_optimized: false
    volumes:
      - device_name: /dev/sda1
        volume_type: gp2
        volume_size: 40
        delete_on_termination: true
  register: ec2

- name: configuring ssh for platform access
  blockinfile:
    state: present
    create: yes
    insertafter: EOF
    path: "{{ ansible_env.HOME }}/.ssh/config"
    block: |
      Host dn_postgresql
          Hostname {{ ec2.instances.0.public_ip }}
          User centos
          IdentityFile {{ playbook_dir }}/{{ keypair.key.name }}-private-key.pem
          IdentitiesOnly yes
          StrictHostKeyChecking no
  when:
    - not ec2|skipped and ec2.changed and ec2.instances|length > 0

# - name: building ansible host group of public IPs
#   add_host: hostname="{{ item.public_ip }}" groups="postgresql" ansible_ssh_private_key_file="./{{ keypair.key.name }}-private-key.pem" ec2_id="{{ item.id }}"
#   with_items: "{{ ec2.instances }}"
#   when:
#     - not ec2|skipped and ec2.changed and ec2.instances|length > 0
#     - item.public_ip|default(None) != None

- name: waiting for AMI to boot
  wait_for:
    host: "{{ item.public_ip }}"
    port: 22
    delay: 30
    timeout: 320
    state: started
  with_items: "{{ ec2.instances }}"
  when:
    - not ec2|skipped and ec2.changed and ec2.instances|length > 0
